# Next.js (App Router) API Development - Step by Step Notes

These notes explain how to build CRUD APIs in Next.js (App Router) using Mongoose, matching the style used in this project.

============================================================
1) Install dependencies
============================================================
- Ensure you have Mongoose installed.

```bash
npm install mongoose
```

============================================================
2) Configure environment variables
============================================================
- Add database credentials in `.env.local` (never commit real secrets):

```env
DB_USER_NAME=your_user
DB_PASSWORD=your_password
DB_NAME=your_db
```

============================================================
3) Create a MongoDB connection helper
============================================================
- File: `src/DB/db.ts` (already in this repo). This ensures a single, reusable connection.

```ts
import { connect } from "mongoose";
// const MONGO_URI = process.env.MONGODB_URL; // alternative
const MONGO_URI = `mongodb+srv://${process.env.DB_USER_NAME}:${process.env.DB_PASSWORD}@cluster0.njebycd.mongodb.net/${process.env.DB_NAME}?retryWrites=true&w=majority&appName=Cluster0`;

if (!MONGO_URI) {
  throw new Error("MONGODB_URL environment variable is not defined.");
}

connect(MONGO_URI)
  .then(() => console.log("MongoDB Connected"))
  .catch((error: any) => console.log(error));
```

- Import this file once at the top of each API route to ensure the DB is connected:

```ts
import "@/DB/db"; // ensure DB connection
```

============================================================
4) Define a Mongoose model (example: User)
============================================================
- File: `src/models/User.ts` (already present). Use the `mongoose.models` check to avoid model overwrite during hot reload.

```ts
import mongoose, { Schema, Document, Model } from "mongoose";

export interface IUser extends Document {
  name: string;
  email: string;
  role: string;
  password: string;
  createdAt: Date;
  updatedAt: Date;
}

export const UserSchema = new Schema<IUser>(
  {
    name: { type: String, required: true, trim: true },
    role: { type: String, required: true, trim: true },
    password: { type: String, required: true, trim: true },
    email: { type: String, required: true, unique: true, lowercase: true, trim: true },
  },
  { timestamps: true }
);

export const User: Model<IUser> =
  mongoose.models.User || mongoose.model<IUser>("User", UserSchema);
```

- Repeat this pattern for other resources (Blog, Faq, Industry). Examples used in this repo:
  - `src/models/Blog.ts`
  - `src/models/Faq.ts`
  - `src/models/Industry.ts`

============================================================
5) Create an API route (example: User GET/POST)
============================================================
- Location pattern with App Router: `src/app/api/<resource>/route.ts`.
- Minimal example showing GET (list/single) and POST (create):

```ts
import { NextResponse } from "next/server";
import "@/DB/db";
import { User } from "@/models/User";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const _id = searchParams.get("_id");
    const ordering = searchParams.get("ordering") || "-createdAt"; // latest first

    const sortField = ordering.startsWith("-") ? ordering.substring(1) : ordering;
    const sortDirection = ordering.startsWith("-") ? -1 : 1;

    if (_id) {
      const result = await User.findById(_id);
      if (!result) return NextResponse.json({ success: false, message: "User not found" }, { status: 404 });
      return NextResponse.json({ success: true, message: "Single User Retrieved", result }, { status: 200 });
    }

    const results = await User.find().sort({ [sortField]: sortDirection });
    return NextResponse.json({ success: true, message: "All Users Retrieved", results }, { status: 200 });
  } catch (error) {
    console.error("Error Getting Users", error);
    return NextResponse.json({ success: false, message: "Failed to Get Users" }, { status: 500 });
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { name, email, password, role } = body;

    if (!name || !email || !password || !role) {
      return NextResponse.json(
        { success: false, message: "Name, Email, Password, and Role are required" },
        { status: 400 }
      );
    }

    const user = await User.create({ name, email, password, role });
    return NextResponse.json({ success: true, message: "User created successfully", user }, { status: 201 });
  } catch (error: any) {
    console.error("Error creating User", error);
    if (error.code === 11000) {
      return NextResponse.json({ success: false, message: "Email already exists" }, { status: 400 });
    }
    return NextResponse.json({ success: false, message: "Failed to create User" }, { status: 500 });
  }
}
```

============================================================
6) Add full CRUD (PUT, PATCH, DELETE)
============================================================
- Common patterns for updates and deletion using `_id` in query string:

```ts
export async function PUT(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const _id = searchParams.get("_id");
    if (!_id) return NextResponse.json({ success: false, message: "_id is required for update" }, { status: 400 });

    const body = await request.json();
    const updated = await User.findByIdAndUpdate(_id, body, { new: true, runValidators: true });
    if (!updated) return NextResponse.json({ success: false, message: "User not found" }, { status: 404 });

    return NextResponse.json({ success: true, message: "User updated successfully", user: updated }, { status: 200 });
  } catch (error: any) {
    if (error.code === 11000) return NextResponse.json({ success: false, message: "Duplicate key error" }, { status: 400 });
    return NextResponse.json({ success: false, message: "Failed to update User" }, { status: 500 });
  }
}

export async function PATCH(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const _id = searchParams.get("_id");
    if (!_id) return NextResponse.json({ success: false, message: "_id is required for update" }, { status: 400 });

    const body = await request.json();
    const updated = await User.findByIdAndUpdate(_id, { $set: body }, { new: true, runValidators: true });
    if (!updated) return NextResponse.json({ success: false, message: "User not found" }, { status: 404 });

    return NextResponse.json({ success: true, message: "User patched successfully", user: updated }, { status: 200 });
  } catch (error: any) {
    if (error.code === 11000) return NextResponse.json({ success: false, message: "Duplicate key error" }, { status: 400 });
    return NextResponse.json({ success: false, message: "Failed to patch User" }, { status: 500 });
  }
}

export async function DELETE(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const _id = searchParams.get("_id");
    if (!_id) return NextResponse.json({ success: false, message: "_id is required for deletion" }, { status: 400 });

    const deleted = await User.findByIdAndDelete(_id);
    if (!deleted) return NextResponse.json({ success: false, message: "User not found" }, { status: 404 });

    return NextResponse.json({ success: true, message: "User deleted successfully" }, { status: 200 });
  } catch (error) {
    return NextResponse.json({ success: false, message: "Failed to delete User" }, { status: 500 });
  }
}
```

============================================================
7) Apply the same pattern to other resources
============================================================
- Create model files:
  - Blog: `src/models/Blog.ts` (title, content, author?, tags[], published?)
  - Faq: `src/models/Faq.ts` (question, answer, category?)
  - Industry: `src/models/Industry.ts` (name unique, description?, icon?)

- Create API routes:
  - `src/app/api/blogs/route.ts`
  - `src/app/api/faq/route.ts`
  - `src/app/api/industries/route.ts`

- Each route should:
  - Import `@/DB/db` and the relevant model
  - Support GET (list with `ordering`, single with `_id`), POST, PUT, PATCH, DELETE
  - Return `{ success, message, ...data }` with proper status codes

============================================================
8) Error handling conventions
============================================================
- 400: Validation errors or missing parameters (e.g., required fields, missing `_id`).
- 404: Resource not found by provided `_id`.
- 409 or 400: Duplicate key (`error.code === 11000`). This repo uses 400 for duplicates.
- 500: Unexpected server errors.

- Response shape example:

```json
{
  "success": false,
  "message": "User not found"
}
```

============================================================
9) Sorting and single fetch (query params)
============================================================
- Support both list and single fetch in GET using query params:
  - `_id=<mongoId>` to fetch a single record
  - `ordering=-createdAt` for descending (or `createdAt` for ascending)

```ts
const { searchParams } = new URL(request.url);
const _id = searchParams.get("_id");
const ordering = searchParams.get("ordering") || "-createdAt";
const sortField = ordering.startsWith("-") ? ordering.substring(1) : ordering;
const sortDirection = ordering.startsWith("-") ? -1 : 1;
```

============================================================
10) Testing endpoints quickly
============================================================
- Create (POST):
```bash
curl -X POST http://localhost:3000/api/user \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","email":"alice@example.com","password":"secret","role":"admin"}'
```

- Get list (GET):
```bash
curl "http://localhost:3000/api/user?ordering=-createdAt"
```

- Get single (GET):
```bash
curl "http://localhost:3000/api/user?_id=<mongoId>"
```

- Update (PUT):
```bash
curl -X PUT "http://localhost:3000/api/user?_id=<mongoId>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice Updated"}'
```

- Patch (PATCH):
```bash
curl -X PATCH "http://localhost:3000/api/user?_id=<mongoId>" \
  -H "Content-Type: application/json" \
  -d '{"role":"editor"}'
```

- Delete (DELETE):
```bash
curl -X DELETE "http://localhost:3000/api/user?_id=<mongoId>"
```

============================================================
11) Folder structure reference (App Router)
============================================================
- API routes live under `src/app/api/.../route.ts`.
- Models live under `src/models`.
- DB connection helper under `src/DB/db.ts`.
- Shared utilities under `src/lib`, UI under `src/components`, hooks under `src/hooks`.
- Path alias `@/*` is configured via `tsconfig.json`.

Full example layout:
```
d:\sudo\sudo-flux\
  .env.local
  next.config.ts
  package.json
  tsconfig.json
  README.md
  public/
    images/
    logo/
  src/
    app/
      (root)/
        page.tsx
        layout.tsx
      (admin)/
        page.tsx
      api/
        user/
          route.ts
        blogs/
          route.ts
        faq/
          route.ts
        industries/
          route.ts
      globals.css
      layout.tsx
      favicon.ico
    DB/
      db.ts
    models/
      User.ts
      Blog.ts
      Faq.ts
      Industry.ts
    lib/
      auth/
      axiosRequest.ts
      getImgToB64.ts
      timeStamp.ts
      utils.ts
      validate/
    components/
      core/
      ui/
      animations/
      home-page/
      DemoForm.tsx
    data/
      blogPosts.ts
    dummy-data/
      dummy-data.ts
    hooks/
      useSmoothScroll.tsx
```

Route naming and patterns:
- Folder name inside `api` becomes the URL: `src/app/api/blogs/route.ts` => `/api/blogs`
- Use one `route.ts` per API segment and export HTTP methods: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`
- Add query params for filters/sorting: `?ordering=-createdAt&_id=<id>`
- For nested routes: `src/app/api/blogs/[id]/route.ts` => `/api/blogs/:id` (optional if you prefer path params)

============================================================
12) Tips
============================================================
- Always import `"@/DB/db"` at the top of API routes to ensure the MongoDB connection is ready.
- Use `mongoose.models.ModelName || mongoose.model("ModelName", schema)` to avoid model overwrite during dev.
- Keep responses consistent: `{ success, message, ... }` with proper HTTP status codes.
- Validate request bodies and query params explicitly and early.

============================================================
13) Auth endpoints (Register, Login, Forgot/Reset, Change Password)
============================================================
- Register: `POST /api/auth/register` — create user with role, password hashed via pre-save hook.
- Login: `POST /api/auth/login` — validates credentials, returns JWT + sanitized user.
- Forgot password: `POST /api/auth/forgot-password` — stores hashed reset token and expiry; return opaque success.
- Reset password: `POST /api/auth/reset-password` — verify token, set new password (re-hashed on save).
- Change password: `POST /api/auth/change-password` — requires Bearer token; verifies current password; sets new password.

Required env vars:
```env
JWT_SECRET=your_jwt_secret
# or reuse existing JWT_SICRECT_KEY configured for NextAuth in this project
```

Security best practices:
- Hash passwords with bcrypt (salt rounds 10); never return password.
- Use `select: false` on password and explicitly `select("+password")` when needed.
- Sign JWTs with strong secret and sensible expiry (e.g., 7d). Store only in httpOnly cookies if building session cookies.
- Do not reveal whether an email exists in forgot-password response.
- In production, send reset links by email; never return raw tokens in API responses.
- Consider rate-limiting login and password endpoints.

End of notes.